
package com.cocinaapp.RecetasMagicas.auth.controller;

import com.cocinaapp.RecetasMagicas.auth.dto.*;
import com.cocinaapp.RecetasMagicas.auth.service.AuthService;
import org.springframework.security.core.Authentication;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
public class AuthController {
    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/register")
    public ResponseEntity<AuthResponseDTO> register(@RequestBody RegisterRequestDTO request) {
        authService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(new AuthResponseDTO("Usuario registrado"));
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponseDTO> login(@RequestBody LoginRequestDTO request) {

        return ResponseEntity.ok(authService.login(request));
    }

    @PostMapping("/validate")
    public ResponseEntity<AuthResponseDTO> validate(@RequestBody ValidationRequestDTO request) {
        authService.validate(request);
        return ResponseEntity.ok(new AuthResponseDTO("Alias y email disponibles"));
    }

    @PostMapping("/validate-code")
    public ResponseEntity<AuthResponseDTO> validateCode(@RequestBody CodeValidationRequestDTO request) {
        authService.validateCode(request);
        return ResponseEntity.ok(new AuthResponseDTO("Código válido"));
    }


    @PostMapping("/recover-password")
    public ResponseEntity<AuthResponseDTO> recoverPassword(@RequestBody PasswordRecoveryRequestDTO request) {
        authService.sendRecoveryCode(request);
        return ResponseEntity.ok(new AuthResponseDTO("Código enviado por correo"));
    }



}
package com.cocinaapp.RecetasMagicas.auth.dto;

import lombok.*;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class AuthResponseDTO {
    private String message;
    // o private String token;


}

package com.cocinaapp.RecetasMagicas.auth.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CodeValidationRequestDTO {
    private String email;
    private String code;
}

package com.cocinaapp.RecetasMagicas.auth.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDTO {
    private String email;
    private String password;
}

package com.cocinaapp.RecetasMagicas.auth.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PasswordRecoveryRequestDTO {
    private String email;
}

package com.cocinaapp.RecetasMagicas.auth.dto;
import jakarta.persistence.Entity;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class RegisterRequestDTO {
    private String alias;
    private String email;
    private String password;
    // Getters/Setters
}

package com.cocinaapp.RecetasMagicas.auth.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ValidationRequestDTO {
    private String alias;
    private String email;
}

package com.cocinaapp.RecetasMagicas.auth.model;

public class Role {
}

package com.cocinaapp.RecetasMagicas.auth.service;

import com.cocinaapp.RecetasMagicas.auth.dto.*;
import com.cocinaapp.RecetasMagicas.config.JwtService;
import com.cocinaapp.RecetasMagicas.exception.EmailAliasExistException;
import com.cocinaapp.RecetasMagicas.util.EmailService;
import com.cocinaapp.RecetasMagicas.user.model.User;
import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final EmailService emailService;

    public AuthService(UserRepository userRepository, PasswordEncoder passwordEncoder, JwtService jwtService, EmailService emailService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtService = jwtService;
        this.emailService = emailService;
    }

    public void register(RegisterRequestDTO request) {
        // 1. Validar si el email o alias ya están en uso
        if (userRepository.existsByEmail(request.getEmail()) || userRepository.existsByAlias(request.getAlias())) {
            throw new EmailAliasExistException("Alias o email ya están registrados");
        }

        // 2. Encriptar contraseña
        String encodedPassword = passwordEncoder.encode(request.getPassword());

        // 3. Crear objeto User
        User user = new User();
        user.setAlias(request.getAlias());
        user.setEmail(request.getEmail());
        user.setPassword(encodedPassword);
        user.setRole("USER"); // o un enum si lo preferís

        // 4. Guardar en la base de datos
        userRepository.save(user);
    }

    public AuthResponseDTO login(LoginRequestDTO request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new RuntimeException("Credenciales inválidas"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("Credenciales inválidas");
        }
        String token = jwtService.generateToken(user.getEmail());
        return new AuthResponseDTO(token);
    }


    public void validate(ValidationRequestDTO request) {
        boolean aliasTaken = userRepository.existsByAlias(request.getAlias());
        boolean emailTaken = userRepository.existsByEmail(request.getEmail());

        if (aliasTaken || emailTaken) {
            throw new EmailAliasExistException("Alias o email ya están en uso");
        }
    }


    private final Map<String, String> codeStorage = new ConcurrentHashMap<>();

    public void storeValidationCode(String email, String code) {
        codeStorage.put(email, code);
    }

    public void validateCode(CodeValidationRequestDTO request) {
        String expectedCode = codeStorage.get(request.getEmail());

        if (expectedCode == null || !expectedCode.equals(request.getCode())) {
            throw new RuntimeException("Código inválido");
        }

        // Opcional: eliminar el código una vez validado
        codeStorage.remove(request.getEmail());
    }

    public void sendRecoveryCode(PasswordRecoveryRequestDTO request) {
        // Validar existencia del email
        if (!userRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("El email no está registrado");
        }

        // Generar código
        String code = String.format("%06d", new Random().nextInt(999999));

        // Guardarlo en el Map
        storeValidationCode(request.getEmail(), code);

        // Enviar por correo
        emailService.sendValidationCode(request.getEmail(), code);
    }




}

package com.cocinaapp.RecetasMagicas.card.controller;

import com.cocinaapp.RecetasMagicas.card.dto.CardRegisterRequestDto;
import com.cocinaapp.RecetasMagicas.card.dto.CardResponseDto;
import com.cocinaapp.RecetasMagicas.card.service.CardService;
import lombok.*;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/tarjetas")
@RequiredArgsConstructor
public class CardController {

    private final CardService cardService;

    @PostMapping("/registrar")
    public ResponseEntity<?> registrarTarjeta(
            @RequestBody CardRegisterRequestDto request,
            Authentication authentication) {
        String email = authentication.getName();
        cardService.registrarTarjeta(request, email);
        return ResponseEntity.ok("Tarjeta registrada exitosamente.");
    }

    @GetMapping
    public List<CardResponseDto> listarTarjetas(Authentication authentication) {
        String email = authentication.getName();
        return cardService.getCardsByUser(email);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> eliminarTarjeta(
            @PathVariable Long id,
            Authentication authentication
    ) {
        String email = authentication.getName();
        cardService.eliminarTarjeta(id, email);
        return ResponseEntity.ok("Tarjeta eliminada correctamente");
    }


}

package com.cocinaapp.RecetasMagicas.card.dto;

import lombok.*;

@Getter @Setter
public class CardRegisterRequestDto {
    private String numero;
    private String titular;
    private String vencimiento;
}

package com.cocinaapp.RecetasMagicas.card.dto;

import lombok.*;

@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class CardResponseDto {
    private Long id;
    private String numeroEnmascarado;
    private String titular;
    private String vencimiento;
}
package com.cocinaapp.RecetasMagicas.card.model;

import com.cocinaapp.RecetasMagicas.user.model.User;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Card {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String numero;
    private String titular;
    private String vencimiento;

    @ManyToOne
    @JoinColumn(name = "usuario_id")
    private User user;
}

package com.cocinaapp.RecetasMagicas.card.repository;

import com.cocinaapp.RecetasMagicas.card.model.Card;
import com.cocinaapp.RecetasMagicas.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface CardRepository extends JpaRepository<Card, Long> {
    List<Card> findAllByUser(User user);
}

package com.cocinaapp.RecetasMagicas.card.service;

import com.cocinaapp.RecetasMagicas.card.dto.CardRegisterRequestDto;
import com.cocinaapp.RecetasMagicas.card.dto.CardResponseDto;
import com.cocinaapp.RecetasMagicas.card.model.Card;
import com.cocinaapp.RecetasMagicas.card.repository.CardRepository;
import com.cocinaapp.RecetasMagicas.user.model.User;
import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import lombok.*;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class CardService {

    private final CardRepository cardRepository;
    private final UserRepository userRepository;

    public Card registrarTarjeta(CardRegisterRequestDto req, String emailUsuario) {
        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
        Card card = new Card();
        card.setNumero(req.getNumero());
        card.setTitular(req.getTitular());
        card.setVencimiento(req.getVencimiento());
        card.setUser(user);
        return cardRepository.save(card);
    }
    public List<CardResponseDto> getCardsByUser(String emailUsuario) {
        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
        List<Card> cards = cardRepository.findAllByUser(user);

        return cards.stream()
                .map(card -> CardResponseDto.builder()
                        .id(card.getId())
                        .numeroEnmascarado(enmascararNumero(card.getNumero()))
                        .titular(card.getTitular())
                        .vencimiento(card.getVencimiento())
                        .build())
                .collect(Collectors.toList());
    }

    // Enmascara el número, muestra solo los últimos 4 dígitos
    private String enmascararNumero(String numero) {
        if (numero == null || numero.length() < 4) return "****";
        String ultimos4 = numero.substring(numero.length() - 4);
        return "**** **** **** " + ultimos4;
    }

    public void eliminarTarjeta(Long cardId, String emailUsuario) {
        // Buscar usuario
        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        // Buscar tarjeta
        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new RuntimeException("Tarjeta no encontrada"));

        // Validar que pertenezca al usuario
        if (!card.getUser().getId().equals(user.getId())) {
            throw new RuntimeException("No autorizado para eliminar esta tarjeta");
        }

        cardRepository.delete(card);
    }



}

package com.cocinaapp.RecetasMagicas.config;

import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UserRepository userRepository;

    @Bean
    public UserDetailsService userDetailsService() {
        return email -> userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService());
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

package com.cocinaapp.RecetasMagicas.config;

import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserRepository userRepository;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        System.out.println("Filtro JWT ejecutado");

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String email;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        email = jwtService.extractEmail(jwt);

        if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            var user = userRepository.findByEmail(email).orElse(null);
            if (user != null && jwtService.isTokenValid(jwt)) {
                var authToken = new UsernamePasswordAuthenticationToken(
                        user,
                        null,
                        user.getAuthorities()
                );
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

package com.cocinaapp.RecetasMagicas.config;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Service
public class JwtService {

    private final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS512);
    private final long expiration = 1000 * 60 * 60; // 1 hora

    public String generateToken(String email) {
        return Jwts.builder()
                .setSubject(email)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public boolean isTokenValid(String token) {
        try {
            extractAllClaims(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private <T> T extractClaim(String token, Function<Claims, T> resolver) {
        final Claims claims = extractAllClaims(token);
        return resolver.apply(claims);
    }
}

package com.cocinaapp.RecetasMagicas.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .requestMatchers(HttpMethod.PUT, "/user/change-password").authenticated()
                        .anyRequest().authenticated()
                )
                .authenticationProvider(authenticationProvider)
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}


package com.cocinaapp.RecetasMagicas.course.controller;

import com.cocinaapp.RecetasMagicas.course.dto.CourseListItemDto;
import com.cocinaapp.RecetasMagicas.course.service.CourseService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/courses")
@RequiredArgsConstructor
public class CourseController {
    private final CourseService courseService;

    @GetMapping("/latest")
    public List<CourseListItemDto> getLatestCourses(@RequestParam(defaultValue = "3") int n) {
        return courseService.getLatestCourses(n);
    }
}


package com.cocinaapp.RecetasMagicas.course.dto;

import lombok.*;

@Getter
@Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class CourseListItemDto {
    private Long id;
    private String descripcion;
    private String modalidad;
    private Double precio;
    private String portada; // Si usás imagen principal
    private String duracion;
    // Agrega otros campos que te interese mostrar
}

package com.cocinaapp.RecetasMagicas.course.model;

import com.cocinaapp.RecetasMagicas.user.model.Alumno;
import lombok.*;

import jakarta.persistence.*;
import java.time.LocalDate;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class AsistenciaCurso {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idAsistencia;

    @ManyToOne
    @JoinColumn(name = "idAlumno", nullable = false)
    private Alumno alumno;

    @ManyToOne
    @JoinColumn(name = "idCronograma", nullable = false)
    private CronogramaCurso cronogramaCurso;

    private LocalDate fecha;
}

package com.cocinaapp.RecetasMagicas.course.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.util.List;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String description;
    private String mainPhoto;
    private String dateStart;

    // Cronograma de clases o temas
    @ElementCollection
    private List<String> cronograma;

    // Relación a sedes
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CronogramaCurso> locations;

    // Precio y promoción (pueden ser null si no aplican)
    private Double price;

    // Modalidad: presencial, virtual, online, etc.
    private String modality;

    // Requisitos, insumos o utensilios
    private String requirements;

    // Estado del curso (puede ser "Abierto", "Cerrado", etc.)
    private String status;
}

package com.cocinaapp.RecetasMagicas.course.model;

import jakarta.persistence.*;
import lombok.*;


@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class CronogramaCurso {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String ubicacion;   // dirección u otros datos

    // Promoción particular para esa sede (opcional)
    private Double promotion; // o porcentaje, como prefieras

    @ManyToOne
    @JoinColumn(name = "sede_id", nullable = false)
    private Sede sede;

    @ManyToOne
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;

}

package com.cocinaapp.RecetasMagicas.course.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Sede {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // corresponde a idSede

    private String nombreSede;
    private String direccionSede;
    private String telefonoSede;
    private String mailSede;
    private String whatsapp;
    private String tipoBonificacion;
    private String bonificacionCursos;
    private String tipoPromocion;
    private String promocionCursos;
}

package com.cocinaapp.RecetasMagicas.course.repository;

import com.cocinaapp.RecetasMagicas.course.model.Course;
import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface CourseRepository extends JpaRepository<Course, Long>, JpaSpecificationExecutor<Course> {
    @Query("SELECT c FROM Course c WHERE LOWER(c.title) LIKE LOWER(CONCAT('%', :query, '%'))")
    List<Course> findByQuery(@Param("query") String query);

    List<Course> findAllByOrderByIdDesc(Pageable pageable);
}

package com.cocinaapp.RecetasMagicas.course.service;

import com.cocinaapp.RecetasMagicas.course.dto.CourseListItemDto;
import com.cocinaapp.RecetasMagicas.course.model.Course;
import com.cocinaapp.RecetasMagicas.course.repository.CourseRepository;
import lombok.*;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CourseService {
    private final CourseRepository courseRepository;

    public List<CourseListItemDto> getLatestCourses(int n) {
        List<Course> courses = courseRepository.findAllByOrderByIdDesc(PageRequest.of(0, n));
        return courses.stream()
                .map(c -> CourseListItemDto.builder()
                        .id(c.getId())
                        .descripcion(c.getDescription())
                        .modalidad(c.getModality())
                        .precio(c.getPrice())
                        .portada(c.getMainPhoto())
                        .duracion(c.getDateStart())
                        .build())
                .toList();
    }
}

package com.cocinaapp.RecetasMagicas.exception;

public class EmailAliasExistException  extends RuntimeException {
    public EmailAliasExistException(String message) {
        super(message);
    }
}

package com.cocinaapp.RecetasMagicas.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(EmailAliasExistException.class)
    public ResponseEntity<String> handleUserAlreadyExists(EmailAliasExistException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body(ex.getMessage());
    }
}
package com.cocinaapp.RecetasMagicas;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RecetasMagicasApplication {

	public static void main(String[] args) {
		SpringApplication.run(RecetasMagicasApplication.class, args);
	}

}

package com.cocinaapp.RecetasMagicas.recipe.controller;


import com.cocinaapp.RecetasMagicas.recipe.dto.RecipeCreateRequest;
import com.cocinaapp.RecetasMagicas.recipe.dto.RecipeDetailDto;
import com.cocinaapp.RecetasMagicas.recipe.dto.RecipeListItemDto;
import com.cocinaapp.RecetasMagicas.recipe.service.RecipeService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequestMapping("recipes")
@RequiredArgsConstructor
public class RecipeController {

    private final RecipeService recipeService;
    private Authentication authentication;

    @GetMapping("/latest")
    public List<RecipeListItemDto> getLatestRecipes(@RequestParam(defaultValue = "3") int n) {
        return recipeService.getLatestRecipes(n);
    }

    @GetMapping("/{id}")
    public RecipeDetailDto getRecipeDetail(@PathVariable Long id) {
        return recipeService.getRecipeDetail(id);
    }

    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> crearReceta(
            @RequestPart("data") RecipeCreateRequest request,
            @RequestPart("mainPhoto") MultipartFile mainPhoto,
            @RequestPart(value = "stepPhotos", required = false) List<MultipartFile> stepPhotos,
            Authentication authentication
    ) {
        String email = authentication.getName();
        recipeService.crearReceta(request, mainPhoto, stepPhotos, email);
        return ResponseEntity.ok("Receta creada exitosamente");
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> eliminarReceta(
            @PathVariable Long id,
            Authentication authentication
    ) {
        String email = authentication.getName();
        recipeService.eliminarReceta(id, email);
        return ResponseEntity.ok("Receta eliminada correctamente.");
    }


}

package com.cocinaapp.RecetasMagicas.recipe.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public
class IngredientDto {
    private double quantity;
    private String detail;
    private String unit;
    private String observations;
}

package com.cocinaapp.RecetasMagicas.recipe.dto;

import lombok.*;

import java.util.List;

@Getter
@Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class RecipeCreateRequest {
    private String title;
    private String description;
    private Integer servings;
    private List<IngredientDto> ingredients;
    private List<StepDto> steps;
}

package com.cocinaapp.RecetasMagicas.recipe.dto;

import lombok.*;
import java.time.LocalDateTime;
import java.util.List;

@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class RecipeDetailDto {
    private Long id;
    private String title;
    private String description;
    private Integer servings;
    private String mainPhoto;
    private String authorAlias;
    private LocalDateTime createdAt;
    private List<IngredientDto> ingredients;
    private List<StepDto> steps;
}


package com.cocinaapp.RecetasMagicas.recipe.dto;
import lombok.*;

import java.time.LocalDateTime;

@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class RecipeListItemDto {
    private Long id;
    private String title;
    private String description;
    private Integer servings;
    private String mainPhoto;
    private String authorAlias;
    private LocalDateTime createdAt;
}

package com.cocinaapp.RecetasMagicas.recipe.dto;

import lombok.*;

import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public
class StepDto {

    private Integer nroPaso;
    private String instruction;
    private List<StepMediaDto> media;
}
package com.cocinaapp.RecetasMagicas.recipe.dto;

import lombok.*;

@Builder
@Getter @Setter @NoArgsConstructor
@AllArgsConstructor
public class StepMediaDto {
    private String tipoContenido;
    private String extension;
    private String urlContenido;
}
package com.cocinaapp.RecetasMagicas.recipe.model;

import lombok.*;

import jakarta.persistence.*;
import java.math.BigDecimal;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Conversion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idConversion;

    @ManyToOne
    @JoinColumn(name = "idUnidadOrigen", nullable = false)
    private Unit unidadOrigen;

    @ManyToOne
    @JoinColumn(name = "idUnidadDestino", nullable = false)
    private Unit unidadDestino;

    @Column(nullable = false, precision = 10, scale = 4)
    private BigDecimal factorConversion;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

import jakarta.persistence.*;
import lombok.*;
import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;

@Entity
@Getter
@Setter
public class Ingredient {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String quantity;
    private String detail;

    @ManyToOne
    @JoinColumn(name = "recipe_id")
    private Recipe recipe;
}


package com.cocinaapp.RecetasMagicas.recipe.model;

import com.cocinaapp.RecetasMagicas.user.model.User;
import jakarta.persistence.*;

@Entity
public class Rating {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Double calificacion;
    private String comentarios;

    @ManyToOne
    private User user;

    @ManyToOne
    private Recipe recipe;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

import com.cocinaapp.RecetasMagicas.recipe.model.Ingredient;
import com.cocinaapp.RecetasMagicas.recipe.model.RecipeStatus;
import com.cocinaapp.RecetasMagicas.recipe.model.Step;
import com.cocinaapp.RecetasMagicas.user.model.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Recipe {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    @JoinColumn(name = "idTipo", nullable = false) // o "tipo_id"
    private RecipeType tipo;
    private Integer likes;
    private String title;
    private String description;
    private Integer servings;
    private String mainPhoto; // path o nombre archivo, o base64 si querés

    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User author;

    @OneToMany(mappedBy = "recipe", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RecipeIngredient> ingredientesUtilizados;

    @OneToMany(mappedBy = "recipe", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Step> steps;

    @Enumerated(EnumType.STRING)
    private RecipeStatus status; // PENDIENTE, APROBADA, RECHAZADA

    @OneToMany(mappedBy = "recipe", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RecipePhoto> fotosAdicionales;

}

package com.cocinaapp.RecetasMagicas.recipe.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RecipeIngredient {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "receta_id")
    private Recipe recipe;

    @ManyToOne
    @JoinColumn(name = "ingrediente_id")
    private Ingredient ingredient;

    private Double cantidad;
    private String unidad;
    private String observaciones;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

import jakarta.persistence.*;

@Entity
public class RecipePhoto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String urlFoto;
    private String extension;

    @ManyToOne
    private Recipe recipe;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

public enum RecipeStatus {
    PENDIENTE,
    APROBADA,
    RECHAZADA
}

package com.cocinaapp.RecetasMagicas.recipe.model;


import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor @AllArgsConstructor @Builder
public class RecipeType {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // esto corresponde a idTipo en SQL

    @Column(nullable = false, length = 100)
    private String descripcion;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

import jakarta.persistence.*;
import lombok.*;
import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;

import java.util.List;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Step {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int nroPaso;

    private String instruction;

    @ManyToOne
    @JoinColumn(name = "receta_id")
    private Recipe recipe;

    @OneToMany(mappedBy = "step", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<StepMedia> media;
}
package com.cocinaapp.RecetasMagicas.recipe.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor
@Builder
public class StepMedia {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String tipoContenido; // "foto", "video"
    private String extension;
    private String urlContenido;

    @ManyToOne
    @JoinColumn(name = "paso_id")
    private Step step;
}

package com.cocinaapp.RecetasMagicas.recipe.model;

import lombok.*;

import jakarta.persistence.*;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Unit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idUnidad;

    @Column(nullable = false, length = 50)
    private String descripcion;
}

package com.cocinaapp.RecetasMagicas.recipe.repository;


import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;
import com.cocinaapp.RecetasMagicas.recipe.model.RecipeStatus;
import com.cocinaapp.RecetasMagicas.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface RecipeRepository extends JpaRepository<Recipe, Long>, JpaSpecificationExecutor<Recipe> {
    // Para N variable:
    List<Recipe> findByStatusOrderByIdDesc(RecipeStatus status, Pageable pageable);

    @Query("SELECT r FROM Recipe r WHERE (LOWER(r.title) LIKE LOWER(CONCAT('%', :query, '%')) OR LOWER(r.description) LIKE LOWER(CONCAT('%', :query, '%'))) AND r.status = 'APROBADA'")
    List<Recipe> findByQueryAndFilter(@Param("query") String query, @Param("filter") String filter, @Param("userId") Long userId);

    boolean existsByTitleAndAuthor(String title, User user);
}
package com.cocinaapp.RecetasMagicas.recipe.service;


import com.cocinaapp.RecetasMagicas.recipe.dto.*;
import com.cocinaapp.RecetasMagicas.recipe.model.*;
import com.cocinaapp.RecetasMagicas.recipe.repository.RecipeRepository;
import com.cocinaapp.RecetasMagicas.user.model.User;
import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.data.domain.PageRequest;
import org.springframework.web.multipart.MultipartFile;

@Service
@RequiredArgsConstructor
public class RecipeService {
    private final RecipeRepository recipeRepository;
    private final UserRepository userRepository;

    public List<RecipeListItemDto> getLatestRecipes(int n) {
        List<Recipe> recipes = recipeRepository.findByStatusOrderByIdDesc(RecipeStatus.APROBADA, PageRequest.of(0, n));
        return recipes.stream()
                .map(r -> RecipeListItemDto.builder()
                        .id(r.getId())
                        .title(r.getTitle())
                        .description(r.getDescription())
                        .servings(r.getServings())
                        .mainPhoto(r.getMainPhoto())
                        .authorAlias(r.getAuthor().getAlias())
                        .createdAt(r.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
    }

    public RecipeDetailDto getRecipeDetail(Long id) {
        Recipe recipe = recipeRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Receta no encontrada"));

        // Solo mostrar receta si está APROBADA (o podés controlar si el usuario logueado es el autor)
        if (recipe.getStatus() != RecipeStatus.APROBADA) {
            throw new RuntimeException("Receta no publicada");
        }

        return RecipeDetailDto.builder()
                .id(recipe.getId())
                .title(recipe.getTitle())
                .description(recipe.getDescription())
                .servings(recipe.getServings())
                .mainPhoto(recipe.getMainPhoto())
                .authorAlias(recipe.getAuthor().getAlias())
                .createdAt(recipe.getCreatedAt())
                .ingredients(recipe.getIngredientesUtilizados().stream()
                        .map(ri -> IngredientDto.builder()
                                .quantity(ri.getCantidad())
                                .unit(ri.getUnidad())
                                .detail(ri.getIngredient().getDetail())
                                .observations(ri.getObservaciones())
                                .build())
                        .collect(Collectors.toList()))
                .steps(recipe.getSteps().stream()
                        .map(s -> StepDto.builder()
                                .nroPaso(s.getNroPaso())
                                .instruction(s.getInstruction())
                                .media(s.getMedia().stream()
                                        .map(m -> StepMediaDto.builder()
                                                .tipoContenido(m.getTipoContenido())
                                                .extension(m.getExtension())
                                                .urlContenido(m.getUrlContenido())
                                                .build())
                                        .collect(Collectors.toList()))
                                .build())
                        .collect(Collectors.toList()))
                .build();

    }
    public void crearReceta(
            RecipeCreateRequest dto,
            MultipartFile mainPhoto,
            List<MultipartFile> stepPhotos,
            String emailUsuario
    ) {
        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        // Validar unicidad de nombre de receta para este usuario
        if (recipeRepository.existsByTitleAndAuthor(dto.getTitle(), user)) {
            throw new IllegalArgumentException("Ya existe una receta con ese nombre para tu usuario.");
        }

        // Guardar foto principal
        String mainPhotoPath = guardarArchivo(mainPhoto, "uploads/recetas/", "principal_" + System.currentTimeMillis());

        // Crear entidad receta
        Recipe receta = new Recipe();
        receta.setTitle(dto.getTitle());
        receta.setDescription(dto.getDescription());
        receta.setServings(dto.getServings());
        receta.setMainPhoto(mainPhotoPath);
        receta.setAuthor(user);
        receta.setStatus(RecipeStatus.APROBADA); // La receta queda publicada automáticamente

        // Ingredientes
        List<RecipeIngredient> ingredientes = new ArrayList<>();
        for (IngredientDto i : dto.getIngredients()) {
            Ingredient ingrediente = new Ingredient();
            ingrediente.setDetail(i.getDetail());
            // ingredienteRepository.save(ingrediente); // Si lo necesitas persistente

            RecipeIngredient ri = new RecipeIngredient();
            ri.setCantidad(i.getQuantity());
            ri.setUnidad(i.getUnit());
            ri.setObservaciones(i.getObservations());
            ri.setIngredient(ingrediente);
            ri.setRecipe(receta);
            ingredientes.add(ri);
        }
        receta.setIngredientesUtilizados(ingredientes);

        // Pasos
        List<Step> steps = new ArrayList<>();
        for (int idx = 0; idx < dto.getSteps().size(); idx++) {
            StepDto stepDto = dto.getSteps().get(idx);
            Step step = new Step();
            step.setNroPaso(idx + 1);
            step.setInstruction(stepDto.getInstruction());
            step.setRecipe(receta);

            List<StepMedia> mediaList = new ArrayList<>();
            // Guardar foto si viene
            if (stepPhotos != null && stepPhotos.size() > idx && stepPhotos.get(idx) != null && !stepPhotos.get(idx).isEmpty()) {
                String stepPhotoPath = guardarArchivo(stepPhotos.get(idx), "uploads/recetas/", "step_" + idx + "_" + System.currentTimeMillis());
                StepMedia media = StepMedia.builder()
                        .tipoContenido("foto")
                        .extension(getExtension(stepPhotos.get(idx).getOriginalFilename()))
                        .urlContenido(stepPhotoPath)
                        .step(step)
                        .build();
                mediaList.add(media);
            }
            // Puedes agregar videos aquí también si tienes.

            step.setMedia(mediaList);
            steps.add(step);
        }
        receta.setSteps(steps);

        // Guardar receta en la base
        recipeRepository.save(receta);
    }
    private String guardarArchivo(MultipartFile archivo, String carpeta, String nombre) {
        try {
            Files.createDirectories(Paths.get(carpeta));
            String path = carpeta + nombre + "_" + archivo.getOriginalFilename();
            archivo.transferTo(new File(path));
            return path;
        } catch (IOException e) {
            throw new RuntimeException("No se pudo guardar el archivo", e);
        }
    }
    private String getExtension (String filename) {
        if (filename == null) return "";
        int dot = filename.lastIndexOf(".");
        return (dot >= 0) ? filename.substring(dot + 1) : "";
    }
    public void eliminarReceta(Long recipeId, String emailUsuario) {
        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
        Recipe receta = recipeRepository.findById(recipeId)
                .orElseThrow(() -> new RuntimeException("Receta no encontrada"));
        if (!receta.getAuthor().getId().equals(user.getId())) {
            throw new RuntimeException("No autorizado para eliminar esta receta.");
        }
        recipeRepository.delete(receta);
    }
}
package com.cocinaapp.RecetasMagicas.search.controller;

import com.cocinaapp.RecetasMagicas.search.dto.SearchResultDto;
import com.cocinaapp.RecetasMagicas.search.dto.SearchFilterDto;
import com.cocinaapp.RecetasMagicas.search.service.SearchService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("search")
@RequiredArgsConstructor
public class SearchController {
    private final SearchService searchService;

    @PostMapping("/search")
    public List<SearchResultDto> search(@RequestBody SearchFilterDto filtro) {
        return searchService.search(filtro);
    }

}

package com.cocinaapp.RecetasMagicas.search.dto;

import com.cocinaapp.RecetasMagicas.course.model.Course;
import com.cocinaapp.RecetasMagicas.course.model.CronogramaCurso;
import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;
import  com.cocinaapp.RecetasMagicas.search.dto.SearchFilterDto;
import lombok.*;

import java.util.List;

@Getter
@Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class SearchFilterDto {
    private String query;                  // texto libre
    private String tipoReceta;             // tipo de receta, por nombre o id
    private List<String> ingredientesIncluidos;
    private List<String> ingredientesExcluidos;
    private Integer porciones;             // o cantidadPersonas
    private Integer tiempoPreparacionMax;  // si lo tenés en el modelo
    private Long autorId;
    private Boolean favoritos;
    private Boolean modificados;
    private Double valoracionMinima;
    private String estado;                 // "aprobada", "pendiente", etc.
    private String fechaDesde;
    private String fechaHasta;
    private String orden;                  // "fecha", "valoracion", "nombre", etc.
    // Para cursos
    private String modalidad;
    private String sede;
    private Double precioMax;
    private Integer vacantesMin;
    private Boolean misCursos;

}

package com.cocinaapp.RecetasMagicas.search.dto;

import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;
import com.cocinaapp.RecetasMagicas.course.model.Course;
import com.cocinaapp.RecetasMagicas.course.model.CronogramaCurso;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SearchResultDto {
    private String tipo;
    private Long id;
    private String titulo;
    private String descripcion;
    private String portada;
    private String inicio;
    private String modalidad;
    private String sede;
    private Double precio;
    private Integer likes;
    private String autorAlias;
    private String tipoReceta;

    public static SearchResultDto fromCourse(Course course) {
        String sede = null;
        if (course.getLocations() != null && !course.getLocations().isEmpty()) {
            CronogramaCurso cc = course.getLocations().get(0);
            if (cc.getSede() != null) {
                sede = cc.getSede().getNombreSede();
            }
        }

        return SearchResultDto.builder()
                .tipo("curso")
                .id(course.getId())
                .titulo(course.getTitle())
                .descripcion(course.getDescription())
                .portada(course.getMainPhoto())
                .inicio(course.getDateStart())
                .modalidad(course.getModality())
                .sede(sede)
                .precio(course.getPrice())
                .likes(null)
                .autorAlias(null)
                .tipoReceta(null)
                .build();
    }

    public static SearchResultDto fromRecipe(Recipe recipe) {
        return SearchResultDto.builder()
                .tipo("receta")
                .id(recipe.getId())
                .titulo(recipe.getTitle())
                .descripcion(recipe.getDescription())
                .portada(recipe.getMainPhoto())
                .inicio(null)
                .modalidad(null)
                .sede(null)
                .precio(null)
                .likes(recipe.getLikes() != null ? recipe.getLikes() : 0)
                .autorAlias(recipe.getAuthor() != null ? recipe.getAuthor().getAlias() : null)
                .tipoReceta(recipe.getTipo() != null ? recipe.getTipo().getDescripcion() : null)
                .build();
    }
}

package com.cocinaapp.RecetasMagicas.search.service;

import com.cocinaapp.RecetasMagicas.course.model.Course;
import com.cocinaapp.RecetasMagicas.course.model.CronogramaCurso;
import com.cocinaapp.RecetasMagicas.recipe.model.Recipe;
import com.cocinaapp.RecetasMagicas.recipe.model.RecipeIngredient;
import com.cocinaapp.RecetasMagicas.recipe.repository.RecipeRepository;
import com.cocinaapp.RecetasMagicas.course.repository.CourseRepository;
import com.cocinaapp.RecetasMagicas.search.dto.SearchResultDto;
import com.cocinaapp.RecetasMagicas.search.dto.SearchFilterDto;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
public class SearchService {
    private final RecipeRepository recipeRepository;
    private final CourseRepository courseRepository;

    public List<SearchResultDto> search(SearchFilterDto filtro) {
        List<SearchResultDto> results = new ArrayList<>();

        // Recetas
        List<Recipe> recetas = recipeRepository.findAll((root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Texto libre (en nombre, descripción)
            if (filtro.getQuery() != null && !filtro.getQuery().isBlank()) {
                String likePattern = "%" + filtro.getQuery().toLowerCase() + "%";
                predicates.add(cb.or(
                        cb.like(cb.lower(root.get("title")), likePattern),
                        cb.like(cb.lower(root.get("description")), likePattern)
                ));
            }

            // Tipo de receta
            if (filtro.getTipoReceta() != null) {
                predicates.add(cb.equal(root.get("tipo").get("descripcion"), filtro.getTipoReceta()));
            }

            // Ingredientes incluidos
            if (filtro.getIngredientesIncluidos() != null && !filtro.getIngredientesIncluidos().isEmpty()) {
                Join<Recipe, RecipeIngredient> ingJoin = root.join("ingredientesUtilizados");
                predicates.add(ingJoin.get("ingredient").get("nombre").in(filtro.getIngredientesIncluidos()));
            }

            // Ingredientes excluidos
            if (filtro.getIngredientesExcluidos() != null && !filtro.getIngredientesExcluidos().isEmpty()) {
                Join<Recipe, RecipeIngredient> ingJoin = root.join("ingredientesUtilizados");
                predicates.add(cb.not(ingJoin.get("ingredient").get("nombre").in(filtro.getIngredientesExcluidos())));
            }

            // Porciones
            if (filtro.getPorciones() != null) {
                predicates.add(cb.equal(root.get("porciones"), filtro.getPorciones()));
            }

            // Valoración mínima
            if (filtro.getValoracionMinima() != null) {
                predicates.add(cb.ge(root.get("valoracionPromedio"), filtro.getValoracionMinima()));
            }

            // Autor
            if (filtro.getAutorId() != null) {
                predicates.add(cb.equal(root.get("author").get("id"), filtro.getAutorId()));
            }

            // Estado
            if (filtro.getEstado() != null) {
                predicates.add(cb.equal(root.get("status"), filtro.getEstado()));
            }

            // Favoritos, modificados, etc.: si se manejan en backend, agregar lógica
            // Orden
            // ...

            query.distinct(true);
            return cb.and(predicates.toArray(new Predicate[0]));
        });

        // Mapear a DTO
        for (Recipe r : recetas) {
            results.add(SearchResultDto.fromRecipe(r));
        }

        // Cursos
        List<Course> cursos = courseRepository.findAll((root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            // Texto libre
            if (filtro.getQuery() != null && !filtro.getQuery().isBlank()) {
                String likePattern = "%" + filtro.getQuery().toLowerCase() + "%";
                predicates.add(cb.like(cb.lower(root.get("descripcion")), likePattern));
            }
            // Modalidad
            if (filtro.getModalidad() != null) {
                predicates.add(cb.equal(root.get("modalidad"), filtro.getModalidad()));
            }
            // Sede
            if (filtro.getSede() != null) {
                Join<Course, CronogramaCurso> croJoin = root.join("cronogramas");
                predicates.add(cb.equal(croJoin.get("sede").get("nombreSede"), filtro.getSede()));
            }
            // Precio máximo
            if (filtro.getPrecioMax() != null) {
                predicates.add(cb.le(root.get("precio"), filtro.getPrecioMax()));
            }
            // Vacantes mínimas
            if (filtro.getVacantesMin() != null) {
                Join<Course, CronogramaCurso> croJoin = root.join("cronogramas");
                predicates.add(cb.ge(croJoin.get("vacantesDisponibles"), filtro.getVacantesMin()));
            }
            // Mis cursos (si manejás inscripciones)
            // ...

            query.distinct(true);
            return cb.and(predicates.toArray(new Predicate[0]));
        });

        for (Course c : cursos) {
            results.add(SearchResultDto.fromCourse(c));
        }

        // Opcional: ordena y pagina resultados
        // results.sort(...);

        return results;
    }

}

package com.cocinaapp.RecetasMagicas.user.controller;

import ch.qos.logback.classic.Logger;
import com.cocinaapp.RecetasMagicas.user.dto.PasswordChangeRequestDTO;
import com.cocinaapp.RecetasMagicas.auth.service.AuthService;
import com.cocinaapp.RecetasMagicas.user.dto.UserResponseDTO;
import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import com.cocinaapp.RecetasMagicas.user.service.AlumnoService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/user")
@RequiredArgsConstructor
public class UserController {
    private final AlumnoService alumnoService;
    private Authentication authentication;


    @PutMapping("/change-password")
    public ResponseEntity<?> changePassword(@RequestBody PasswordChangeRequestDTO request, Authentication authentication) {
        String email = authentication.getName();

        alumnoService.changePassword(email, request.getNewPassword());
        return ResponseEntity.ok(new UserResponseDTO("Contraseña actualizada con éxito"));
    }

    @PostMapping(value = "/dni", consumes = "multipart/form-data")
    public ResponseEntity<?> subirDni(
            @RequestParam("dniFrente") MultipartFile dniFrente,
            @RequestParam("dniDorso") MultipartFile dniDorso,
            @RequestParam("numeroTramite") String numeroTramite
    ) {
        String email = authentication.getName();
        alumnoService.registrarAlumno(email, dniFrente, dniDorso, numeroTramite);
        return ResponseEntity.ok("Fotos y número de trámite recibidos correctamente.");
    }
}

package com.cocinaapp.RecetasMagicas.user.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PasswordChangeRequestDTO {
    private String newPassword;
}

package com.cocinaapp.RecetasMagicas.user.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class UserResponseDTO {
    private String message;
    // o private String token;


}

package com.cocinaapp.RecetasMagicas.user.model;

import lombok.*;
import jakarta.persistence.*;

@Entity
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class Alumno {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idAlumno;

    private String numeroTarjeta;
    private String numeroTramite;
    private String nombre;           // Podrías hacer referencia a User si tenés relación
    private String PathDniFrente;
    private String PathDniDorso;

    // Si tu modelo lo necesita: relación uno a uno con User

    @OneToOne
    @JoinColumn(name = "idUsuario", referencedColumnName = "id")
    private User user;
}
package com.cocinaapp.RecetasMagicas.user.model;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {

    @Id
    @GeneratedValue
    private Long id;
    private String alias;
    private String email;
    private String password;
    private String role = "USER"; // Podés usar enum si querés más seguridad

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role)); // Ej: "USER"
    }

    @Override
    public String getUsername() {
        return email; // Lo que usás para autenticar
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}

package com.cocinaapp.RecetasMagicas.user.repository;

import com.cocinaapp.RecetasMagicas.user.model.Alumno;
import com.cocinaapp.RecetasMagicas.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AlumnoRepository extends JpaRepository<Alumno, Long> {

    Optional<Alumno> findByUser(User user);

    boolean existsByUser(User user);

    boolean existsByDniNif(String dniNif);

    boolean existsByNumeroTramite(String numeroTramite);

    Optional<Alumno> findByNumeroTramite(String numeroTramite);

    // Otros métodos custom según necesidad...
}
package com.cocinaapp.RecetasMagicas.user.repository;

import com.cocinaapp.RecetasMagicas.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    boolean existsByEmail(String email);
    boolean existsByAlias(String alias);
    Optional<User> findByEmail(String email);
}

package com.cocinaapp.RecetasMagicas.user.service;

import com.cocinaapp.RecetasMagicas.user.model.Alumno;
import com.cocinaapp.RecetasMagicas.user.model.User;

import com.cocinaapp.RecetasMagicas.user.repository.AlumnoRepository;
import com.cocinaapp.RecetasMagicas.user.repository.UserRepository;
import com.cocinaapp.RecetasMagicas.util.ValidateDNI;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

@Service
@RequiredArgsConstructor
public class AlumnoService {
    private final PasswordEncoder passwordEncoder;
    private final AlumnoRepository alumnoRepository;

    private final UserRepository userRepository;

    public void registrarAlumno(
            String emailUsuario, MultipartFile dniFrente, MultipartFile dniDorso, String numeroTramite) {

        User user = userRepository.findByEmail(emailUsuario)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
        if (!ValidateDNI.ValidateNroTramite(numeroTramite, alumnoRepository)){
            throw new IllegalArgumentException("Numero de Tramite ya registrado");
        }

        // Guardar los archivos (ejemplo simple)
        String baseDir = "uploads/dni/";
        String pathFrente = baseDir + "dni_frente_" + user.getId() + "_" + dniFrente.getOriginalFilename();
        String pathDorso = baseDir + "dni_dorso_" + user.getId() + "_" + dniDorso.getOriginalFilename();

        try {
            Files.createDirectories(Paths.get(baseDir));
            dniFrente.transferTo(new File(pathFrente));
            dniDorso.transferTo(new File(pathDorso));
        } catch (IOException e) {
            throw new RuntimeException("Error guardando las fotos del DNI", e);
        }

        // Crear y guardar el alumno
        Alumno alumno = new Alumno();
        alumno.setUser(user);
        alumno.setNumeroTramite(numeroTramite);
        alumno.setPathDniFrente(pathFrente);
        alumno.setPathDniDorso(pathDorso);
        // ... otros campos si hacen falta

        alumnoRepository.save(alumno);
    }

    public void changePassword(String email, String newPassword) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }
}

package com.cocinaapp.RecetasMagicas.util;

import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Component;

@Component
public class EmailService {

    private final JavaMailSender mailSender;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendValidationCode(String to, String code) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject("Código de recuperación");
        message.setText("Tu código de recuperación es: " + code);
        mailSender.send(message);
    }
}

package com.cocinaapp.RecetasMagicas.util;

import com.cocinaapp.RecetasMagicas.user.repository.AlumnoRepository;

public class ValidateDNI {
    static public boolean ValidateNroTramite(String nroTramite, AlumnoRepository repo) {
        if (!nroTramite.matches("\\d{11}")) return false; // Trámite: 11 dígitos
        if (repo.existsByNumeroTramite(nroTramite)) return false; // No repetido
        return true;
    }
}
